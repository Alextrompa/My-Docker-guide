\documentclass[]{article}

\usepackage[utf8]{inputenc}
\usepackage[total={17cm,21cm},top=2.5cm, left=2.3cm]{geometry}


\title{Administración de aplicaciones Docker}
\author{Alejandro Martínez Fernández}

\makeindex


\begin{document}
\begin{titlepage}
	\maketitle
\end{titlepage}
\tableofcontents
\section{Descripción y definición de conceptos}

\vspace{3mm}

\begin{enumerate}
\renewcommand{\labelenumi}{$ \bullet $}

\item{\bf Imagen:} Una Imagen son, básicamente, instrucciones para la creación de un contenedor.
Estas son de solo lectura.

\item{\bf Contenedor:} Es una instancia ejecutable de una imagen. Se pueden crear, poner en marcha, parar, mover o borrar. Incluso se puede crear una Imagen a partir del estado actual de un contenedor.

\item{\bf Volumen:} Es la mejor forma para que los datos en un contenedor se almacenen de una manera persistente y se conserven aún después de eliminar el contenedor. Facilita que varios contenedores compartan el sistema de ficheros. Son administrados directamente por Docker, por lo que son sencillos de mantener. El usuario puede crearlos, borrarlos y modificarlos.

\item{\bf Montaje ligado:} Parecidos a los volúmenes, aunque tienen una funcionalidad más limitada. Mientras que los volúmenes se almacenan de manera aislada, los montajes ligados consisten en montar un fichero o directorio en un contenedor. El fichero es referenciado por su ruta.

\hspace{1cm} Peligroso: El sistema de ficheros de la máquina queda expuesto ante los programas del contenedor por lo que podrían modificarlo.

\item{\bf Montaje tmpfs:} Esta opción solo se puede utilizar en linux, y se utiliza cuando no queremos que los datos del contenedor perduren en el tiempo. Esto puede ser así por seguridad, porque el contenedor puede manejar una gran cantidad de datos o por cualquier otro motivo.


 \item{\bf Registry:} Un registry es una base de datos de imágenes. O dicho de otra forma, un sitio donde guardar las imágenes, un hub.	El registry más famoso es el Docker Hub o Docker Store, donde podemos crear una cuenta de usuario y subir nuestras imágenes (también descargarlas).
 Registry es en sí otra imágen, por lo que sí, podemos descargarla, hacer un contenedor con ella y guardar en el mismo nuestras imágenes.
			
\end{enumerate}

\section{Administración de imágenes y contenedores}

\subsection{Pull}

Empecemos la administración, actualmente no tenemos ninguna imagen con la que crear contenedores, así que lo primero que debemos hacer es descargar alguna.
Para descargar una imagen utilizamos el comando pull.

\begin{center}
	
	Descargamos la imagen "hello-world":
	\vspace{1mm}
	\\
	\em docker pull hello-world
	
\end{center}

Además, este comando tiene opciones.
Una opción es $ -a,--all $ que hace que se descarguen todas las versiones de una imagen.

\begin{center}
Ejemplo  ( {\bf NO} usar, demasiadas versiones): 
\\
\vspace{1mm}
\em docker -a docs/docker.github.io

\end{center}

La otra opción, aunque no muy relevante, es  {\it --disable-content-trust }  que no verifica el contenido de la imagen.


\subsection{Create}

Ahora que tenemos una imagen descargada, vamos a crear un contenedor con ella.

\begin{center}

	\it docker create hello-world

\end{center}

Como podemos ver, no se ha producido salida alguna, salvo el id del contenedor. Esto es así porque el contenedor se ha creado, pero no se ha puesto en marcha.

\subsection{Start}

Ahora vamos a activar el contenedor que acabamos de crear, para ello escribimos:

\begin{center}
	
	\it docker start -a {\bf ID}
	\\ Siendo {\bf ID} la salida del comando anterior.
\end{center}

Este comando activa contenedores que están parados.
Estos contenedores pueden estar parados porque que se les haya detenido desde fuera (ahora lo vemos) o porque se hayan creado pero no se hayan puesto en marcha.
Opciones:

\begin{enumerate}

\renewcommand{\labelenumi}{$ \bullet $}

	\item {\bf -a, --attach} Une la salida estándar y de error a la del terminal.
	
	\item {\bf--detach-keys} Anula la secuencia de teclas para separarla del contenedor.
	
	\item {\bf-i, --interactive} Une la entrada estándar del contenedor a la del terminal (muy interesante con otras imágenes que veremos más adelante). 

\end{enumerate}


\subsection{Run}

Ahora que ya sabemos como descargar imágenes, crear contenedores y ponerlos en marcha se nos viene a la mente una pregunta ¿No hay una forma más rápida?.
La respuesta es que sí, y es el comando run.
Vamos a ver un ejemplo rápido y sencillo para entenderlo:

\begin{center}

	\it docker run hello-world

\end{center}

Ahora, para ver como funcionan algunas de las muchas opciones que tiene este comando vamos a ver más ejemplos:

\begin{center}

	\it	docker run -it ubuntu
	
\end{center}

Con este comando creamos y entramos a controlar un contenedor cuya imagen es un SO. En este contenedor podemos escribir los comandos de bash que conocemos, desde un find hasta un apt, pasando por cualquier comando instalado. Además, dentro de este contenedor hay un sistema de ficheros, como el de cualquier sistema linux. Vamos a escribir las siguientes órdenes en este contenedor:
\begin{center}
	
	\it
	cd /home\\
	mkdir usuario\\
	cd usuario\\
	mkdir Escritorio\\
	cd Escritorio\\
	echo "Creo un fichero y le introduzco un texto" > Mifichero.txt\\
	exit

\end{center}
Las opciones que hemos puesto en el anterior comando son:
\begin{enumerate}
\renewcommand{\labelenumi}{$ \bullet $}

\item {\it -i} interactive, mantiene abierta la entrada estándar del contenedor en el términal. Necesaria para los sistemas operativos.
\item {\it -t} Asgina un pseudo -TTY, lo que hace que sea correcto su uso para la utilización de un shell interactivo.

\end{enumerate}
Otra cosa de la que podemos habernos dado cuenta es que nosotros no teníamos descargada la imagen ubuntu, pero aún así se ha creado el contenedor apropiado.
Esto es debido a que, tanto run como create, descargan la imagen ordenada del Docker Hub cuando no la encuentran localmente.
\\\\

Otro ejemplo muy interesante:

\begin{center}

	\it docker run -t -p 4000:4000 docs/docker.github.io:latest

\end{center}
La imagen que acabamos de utilizar es la propia documentación oficial de Docker, que podemos visualizar, como nos dice la propia salida, escribiendo 0.0.0.0:4000 en un navegador.
Las opciones que hemos puesto en este comando son:
\begin{enumerate}
\renewcommand{\labelenumi}{$ \bullet $}
	
\item {\it -t}
 El efecto es el mismo que antes, pero en este caso, la diferencia entre ponerlo y no ponerlo, es que si pulsamos las teclas {\bf Ctrl + C} y la opción no está puesta, recuperamos el prompt del sistema, pero el contenedor termina y la documentación ya no es accesible. Si la opción está puesta, como en este caso, podemos recuperar el terminal y seguir visualizando la documentación.

\item {\it -p X:Y} 
El contenedor está escuchando en su puerto Y (podemos imaginar que es un puerto virtual), lo que hacemos es que el puerto X de la máquina se iguala a ese puerto Y (que es el que especifica la imagen). De esta forma es como se consigue que un contenedor haga uso de la red.

\end{enumerate}

El comando run tiene muchas más opciones aparte de las vistas en los ejemplos anteriores.
A continuación se muestran algunas opciones más:

\begin{enumerate}
\renewcommand{\labelenumi}{$ \bullet $}

\item {\bf -a, --attach}

			Liga el terminal con la salida estandar, la entrada estandar o la salida de error estandar del programa ejecutado.
			Esta opción debe ejecutarse en modo de primer plano y es la que se utiliza por defecto.
			No es necesario ligar las tres salidas, sino que puede elejirse que salidas se ligan.
	
\item {\bf --add-host=[]}
	
			Añade un host IP custom con el formato host:ip
			También añade una línea a /etc/hosts.
			Esta opción se puede usar varias veces.
	
\item {\bf -c=X, --cpu-shares=X}
	
			Por defecto se utiliza la opción -c=1024.
			El parámetro X se utiliza para repartir de manera proporcional el tiempo de CPU entre todos los contenedores cuando estos intentan utilizar más del 100%.
			Si por ejemplo tenemos tres contenedores ejecutándose en el sistema con 512, 512 y 1024 respectivamente, el tiempo se repartirá de la siguiente forma: 25%, 25% y 50%.
			Nota: Si se disponen de varios nucleos, el sistema repartirá el tiempo de CPU llevando en cuenta todos ellos.
	
	
\item {\bf --cpu-count=X}
	
			Limita el número de CPUs disponibles para la ejecución de contenedores a X.
			En Windows Server se aproxima al porcentaje de uso de la CPU.
	
\item {\bf --cpu-percent=X}
	
			Limita el porcentaje de uso de CPU disponible para la ejecución de contenedores a X.
	
\item {\bf --cpu-period=X}
	
			Esta opcíon se utiliza para modificar el tiempo de CPU que el planificador concede a los procesos de los contenedores.
	
\item {\bf --cpu-rt-period=X}
	
			Con esta opción podemos limitar el periodo de uso de CPU a un determinado tiempo real en microsegundos.
	
\item {\bf --dns=[]}
	
			Utiliza un servidor de DNS diferente al por defecto.
	
			Esta opción puede ser usada para sobrescribir la configuración que se le proporciona al contenedor.
			Normalmente esta opción es necesaria cuando la configuración DNS falla. En este caso, siempre que se ejecute algo habrá que utilizarla.
	
\item {\bf -m, --memory=""}
	
			Permite añadir una restricción de memoria al contenedor con el formato <número>[<unidad>], donde unidad puede ser b, k, m o g.
			Si el sistema soporta memoria swap, esta restricción puede ser mayor que la propia memoria física.
	
\item {\bf --memory-reservation=""}
	
			Mismo formato que el anterior.
			Al añadir este flag, si el sistema detecta que hay poca memoria restante, el sistema obliga a los contenedores a limitar su consumo a
			lo que se les haya reservado con este comando.
			Cuando hagamos uso de esta opción deberiamos establecer un límite por debajo del de la opción anterior (pues la anterior opción es como
			un límite hard y esta como uno soft). Por defecto, la memoria reservada es la misma que la establecida con la opción anterior.
	
\item {\bf --memory-swap=""}
	
			Establece el límite de memoria swap que puede utilizar un contenedor. Esta opción debe ser siempre utilizada con la opción -m.
			El formato utilizado con esta opción es el mismo que el de las dos opciones anteriores, pero si no especificamos unidad se utiliza b.
			El límite establecido debería ser mayor que el de la opción -m.
			Por defecto se establece al doble de la opción -m.
			Si no queremos limitar la memoria swap, utilizaremos -1 como límite.
	
\item {\bf --name}
	
			Establece un nombre para el contenedor que se va a poner en ejecución. Esta opción es muy útil, pues luego podemos referirnos al contenedor por su nombre (haremos esto) en lugar de por su ID
			(si no se da un nombre a un contenedor, se le asigna uno aleatorio).

\end{enumerate}

\subsection{Ps}

Ahora que hemos puesto algunos contenedores en marcha, vamos a entrar ver el estado general del sistema. Para esto vamos a utilizar la orden
{\it ps} que lista los contenedores. Vamos a ver un ejemplo:

\begin{center}
\it
	docker ps
	\\
	\vspace{1mm}
	docker ps -a
	\\
	\vspace{1mm}
	docker ps --filter status=exited
\end{center}
El primer comando muestra todos los contenedores que se estén ejecutando en este momento.
La salida del comando es la siguiente:
\begin{enumerate}
	\item {\bf CONTAINER ID}
	
		ID "corto" del contenedor, sobran las descripciones.
		
	\item {\bf IMAGE}
	
		Imagen utilizada para crear el contenedor.
	\item {\bf COMMAND}
	
		Programa que se está ejecutando dentro del contenedor.
	\item {\bf CREATED}
	
		Cuanto tiempo ha pasado desde que se creó.
	\item {\bf STATUS}
	
		Estado actual del contenedor (corriendo, terminado, pausado, etc).
	\item {\bf PORT}
	
		Puertos utilizados por el contenedor.
	\item {\bf NAME}
	
		Nombre del contenedor (el que hayamos puesto al crearlo o le haya asignado el sistema).

\end{enumerate}

El resto de comandos utilizan unas opciones las cuales vamos a explicar a continuación junto con el resto de opciones del comando:

\begin{enumerate}
	\renewcommand{\labelenumi}{$ \bullet $}
	\item {\bf -a, --all}
	
		Muestra todos los contenedores.
	\item {\bf -s, --size}
		
		Añade una columna con el tamaño de los ficheros del contenedor.
		
	\item {\bf -q, --quiet}
	
		Solo muestra los IDs de los contenedores.
		
	\item {\bf --no-trunc}
	
		No recorta el tamaño de la salida.
	\item {\bf -n X, --last X}
	
		Muestra sólo los X últimos contenedores creados.
	\item {\bf --latest, -l}
	
		Muestra sólo el último contenedor creado. Equivale a "-n 1".
	\item {\bf --format}
	
		Usando una plantilla Go, podemos formatear la salida.
	\item {\bf -f, --filter}
	
		Con esta opción, podemos añadir condiciones. En la salida solo se mostrarán los contenedores que las cumplan.
		Las condiciones que podemos poner pueden abarcar cosas como el id, el nombre o las networks que utilizan.

\end{enumerate}

\subsection{Stop}
Ahora que hemos visto como poner contenedores en marcha, vamos a ver como pararlos.
Para esto utilizamos el comando {\it "stop"}. Tras un periodo de gracia (que desconozco cuál es por defecto), los mata si no se han parado. Después de esto, si vemos su estado con {\it docker ps}, será terminado. Vamos a ver un ejemplo:

\begin{center}
\it
docker stop NOMBRE

\end{center}
En el campo {\bf NOMBRE} pon el nombre de cualquiera de los contenedores que hemos abierto hasta ahora.
Este comando solo tiene una opción, {\bf -t, --time} que especifica el periodo de gracia en segundos a esperar por el comando antes de matarlo. Si a esta opción no le acompañaun tiempo, usa diez segundos.

\subsection{Rename}
Y ahora, ¿qué pasa si creando un contenedor me olvido de darle un nombre o me equivoco?
Bien, Docker ha pensado también en esto. Con el comando {\bf rename} podemos cambiar el nombre de un contenedor.
Vamos a ver un ejemplo:
\begin{center}
\it
docker rename NOMBRE nombre\_nuevo

\end{center}
Ahora, el antiguo contenedor {\bf NOMBRE} se llama \textbf{\textit {nombre\_nuevo}}.

\subsection{Pause}
Otro comando muy interesante es el comando {\it pause} que para la ejecución de un contenedor (más concretamente, para a los procesos de dentro del contenedor) de la misma forma que lo hace la combinación
de teclas {\bf Ctrl + Z} en un terminal.
Ejemplo:
\begin{center}
	\it
	docker pause NOMBRE
	\\
	\vspace{1mm}
	(Como siempre, \textbf{NOMBRE} es el nombre de un contenedor. No lo voy a decir más)
\end{center}
Si a continuación utilizamos el comando {\it docker ps} veremos que el contenedor sigue en ejecución, pero ha sido detenido.

\subsection{Unpause}
Acabamos de parar los procesos de un contenedor, ahora vamos a ver como reanudarlos.
El comando que vamos a utilizar es \textbf{unpause}.
Para utilizarlo simplemente seguimos la sintaxis del ejemplo:
\begin{center}
	\it docker unpause NOMBRE
\end{center}

\subsection{Kill}
Ahora vamos a matar contenedores, para ello vamos a usar el comando \textbf{kill}.
\begin{center}
	\textit{docker kill NOMRE}
\end{center}
Si utilizamos el comando \textit{docker ps -a} podemos ver que la situación final del contenedor es la misma que utilizando la orden stop.
La diferencia entre las ordenes es la señal utilizada, pues aquí usamos SIGKILL.
Otra característica muy interesante es que la única opción disponible \textit{(-s, --signal)} nos permite enviar otra señal al contenedor.
\hspace{1cm} Nota: En realidad la señal se envía al proceso principal del contenedor, no al contenedor en sí.
\begin{center}
	\it
	docker kill -s KILL NOMBRE
\end{center}

\subsection{Restart}
La siguiente orden que vamos a ver es \textbf{restart} que reinicia o relanza un contenedor.
Esta opción puede ser interesante si un contenedor da problemas. Además este comando no afecta al espacio de memoria de un contenedor, por lo que no se pierden cambios.
Ejemplo:
\begin{center}
\it docker restart NOMBRE
\end{center}

\subsection{Update}
Antes hemos hablado sobre el problema de equivocarnos poniendo el nombre de un contenedor, pero, nos podemos equivocar en otros detalles (mucho más importante que el nombre) en la creación de este. Por esta razón existe el comando \textbf{update} que actualiza la configuración de un contenedor. De esta forma podemos, tanto corregir errores como poner la configuración de un contenedor al día si por ejemplo cambian el contexto de la máquina (durante la realización de esta guía, podemos ir creando más contenedores según veamos y jugando un poco con ellos).
Veamos un ejemplo:
\begin{center}
	\it
	docker update --cpus 1 NOMBRE
\end{center}
La explicación de este comando recae en las opciones utilizadas, pues es en ellas donde se especifica la nueva configuración del contenedor.
Vamos a ver algunas de las opciones que tiene este comando:

\begin{enumerate}
\renewcommand{\labelenumi}{$ \bullet $}

\item {\bf --cpu-period}

Modifica el tiempo de CPU que el planificador concede a los procesos de los contenedores.

\item {\bf --cpu-quota}

Modifica el porcentaje de tiempo de CPU que el planificador concede a los procesos contenedores.

\item {\bf --cpus}

Limita el número de CPUs que puede utilizar el contenedor.

\item {\bf -m, --memory}

Limita la memoria que puede usar el contenedor.

\item {\bf --memory-reservation}

Cuando se detecta que queda poca memoria restante el sistema obliga a los contenedores a utilizar como mucho esta cantidad de memoria. Evidentemente, esta debe ser menor que la memoria límite.

\item {\bf --memory-swap}

Establece el limite de memoria swap que puede utilizar un contenedor.

\end{enumerate}

\subsection{Attach}

Un contenedor ya en ejecución se puede unir a un terminal (como si hubiesemos utilizado la opción -a del run) con  el comando {\bf attach}.
Ejemplo:
\begin{center}
	\it
	docker run --name nombre -it ubuntu\\
	~Realizamos acciones dentro del contenedor y al final usamos exit~\\
	docker start nombre\\
	docker attach nombre\\

\end{center}
Si hacemos esto, podemos ver que nos hemos vuelto a conectar al mismo contenedor del que habíamos salido.
Esta orden es muy interesante cuando, por ejemplo, apagamos la máquina y queremos volver a conectarnos al contenedor.


Opciones:
\begin{enumerate}

\item {\bf --no-stdin}

No liga la entrada estandar, interesante si solo queremos la salida.

\item {\bf --sig-proxy}

	Atrapa todas las señales del proceso.

\end{enumerate}


\subsection{Port}
El siguiente comando ({\bf port}) muestra los puertos que está utilizando un contenedor.
Estos puertos no están separados de los de la máquina real, por lo que es así como se consigue la comunicación del contenedor con el exterior.
Vamos a ver un ejemplo:
\begin{center}
	\it
	docker run -it --name contenedor -p 4000:4000 docs/docker.github.io:latest\\
	docker port contenedor
\end{center}

\subsection{Cp}

Describamos una situación ficticia, hemos estado trabajando dentro de un contenedor con un fichero, y queremos copiarlo para enviarlo a alguien o tenerlo guardado en otro sitio.
Para esto vamos a utilizar el comando {\bf cp} que copia ficheros entre contenedores y el sistema de ficheros local.
Ejemplo:

\begin{center}
\it
docker cp nombre:/FICHERO /RUTA
\end{center}
\textbf{/FICHERO} es la ruta del fichero del contenedor {\bf nombre} que queremos copiar a {\bf RUTA}.
Si el fichero que se va a copiar es un directorio, este se copiará recursivamente (por lo que podemos decir que docker cp equivale al cp -a de Unix).

Opciones:

\begin{enumerate}
	
\renewcommand{\labelenumi}{$ \bullet $}

\item {\bf -a, --archive}

Copia también los UID y GID de los ficheros.

\item {\bf -L, --follow-link}

Si en alguna de las rutas, se utiliza un enlance simbólico a un directorio, este se sigue.

\end{enumerate}


\subsection{Rm}

Después de haber creado y administrado contenedores, le llega el turno a {\bf rm} que borra contenedores que estén parados.
Si se borran, ya no se podrán volver a activar (de hecho, dejarán de aparecer en {\it docker ps -a}).
Ejemplo:

\begin{center}
	\it
	docker rm NOMBRE
\end{center}

Opciones:

\begin{enumerate}
	\renewcommand{\labelenumi}{$ \bullet $}
	\item {\bf -f, --force}
	
	Fuerza la eliminación del contenedor elegido. Para esto envía la señal SIGKILL. 
	Aunque los contenedores deben estar parados, pueden estar corriendo si usamos esta opción.
	\item {\bf -l, --link}
	
	Borra los enlaces especificados.
	\item {\bf -v, --volumes}
	
	Borra los volúmenes asociados a los contenedores.
\end{enumerate}

\subsection{exec}

Ahora vamos a ver el comando {\bf exec}, una orden que creo tiene mucha utilidad, pues, por ejemplo, deja de ser necesario entrar dentro de un contenedor para ejecutar un solo comando.
Como ya se puede deducir, {\it exec} ejecuta un comando dentro de un contenedor.
El comando utilizado solo estará activo mientras el proceso principal del contenedor lo esté.
El comando no se reiniciará si el contenedor es reiniciado.
Se utilizará el directorio por defecto del contenedor.
Si la imagen subyacente tiene especificado un directorio diferente, se usará este en su lugar. 
El comando deberá ser ejecutable.
Veamos un ejemplo:
\begin{center}
	\it
	docker exec NOMBRE -t top
\end{center}

Opciones:

\begin{enumerate}
\renewcommand{\labelenumi}{$ \bullet $}
\item {\bf -d, --detach}

Ejecutar en segundo plano con respecto a este terminal.
\item {\bf -i, --interactive}

Mantiene la entrada estándar abierta aunque no se haya ligado.
\item {\bf --privileged}

Da privilegios extendidos al comando.
\item {\bf -t, --tty}

Establece un pseudo-tty.
\item {\bf -u, --user}

UID.

\end{enumerate}

\subsection{Export}
{\bf Export} es el siguiente comando.
Exporta el contenido del sistema de ficheros de un contenedor como un fichero tar.
Este comando es interesante para la realización de copias de seguridad.
Debemos tener en cuenta que no funciona con volúmenes.
Ejemplo:
\begin{center}
	\it
	docker export NOMBRE > comprimido.tar
\end{center}

Aquí solo tenemos una opción, {\it -o, --output} que introduce la salida en el fichero especificado en vez de en la salida estándar.
Viendo esto se puede decir que utiliza la misma sintaxis que cpio.

\subsection{Wait}
Wait bloquea la terminal hasta que el contenedor (o contenedores) seleccionados terminen su ejecución.
Cuando se pare la ejecución del contenedor seleccionado, el terminal mostrará el código de salida del contenedor y se desbloqueará.
Para este ejemplo necesitaremos dos terminales, las instrucciones en {\bf negrita} irán a uno y las otras al otro:
\begin{center}
	\textit{
		docker run -it --name unnombre ubuntu\\
		\textbf{docker wait unnombre}\\
		\it exit
	}
\end{center}

\subsection{Events}

\end{document}





